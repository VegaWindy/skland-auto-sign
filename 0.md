我们面临的问题是：GitHub仓库如果60天内没有活动，会禁用workflow。而我们的workflow每天运行一次，但显然运行workflow不算活动事件？或者可能GitHub对“活动”的定义不包括workflow的运行？
实际上，GitHub的“活动”通常包括push、issue、PR等，而workflow的运行事件并不算在仓库活动内。因此，即使workflow每天运行，仓库仍可能被标记为不活动，导致60天后禁用workflow。
解决方案思路：
1. 增加一个定期任务（比如每50天一次），该任务会向仓库进行一次无关紧要的提交（比如更新一个时间戳文件），从而激活仓库。
2. 使用GitHub API来定期触发一个事件（比如创建然后关闭一个issue），但这种方法可能会产生很多issue，不太优雅。
3. 使用外部服务（如UptimeRobot）定期访问仓库，但外部访问并不能直接算作仓库活动。
这里推荐第一种方法：在workflow中添加一个额外的任务，每50天左右进行一次空提交。这样就能保证在60天期限到达前有一次提交活动。
具体步骤：
- 在现有的workflow中添加一个步骤，这个步骤只在特定的条件下运行（比如每50天一次）。
- 该步骤会执行一个空提交（比如修改一个文件然后提交）。
但是，注意：我们的workflow每天运行一次，所以我们可以设置一个条件：每隔50天执行一次空提交。
如何实现每隔50天执行一次？
我们可以通过计算当前日期距离某个固定日期的天数，然后对50取模，当模为0时执行。但这样需要记录一个固定日期，不太灵活。
另一种简单方法：使用GitHub Actions的schedule事件，设置两个cron：
1. 一个cron用于每天的签到任务（不变）。
2. 另一个cron每50天运行一次，执行空提交。
但是，cron表达式不支持“每50天”这样的间隔。所以我们可以考虑在同一个workflow中，每天运行的时候判断一下：如果距离上次空提交已经过了50天，那么执行一次空提交。
具体做法：
- 在仓库中创建一个文件（比如last_commit_trigger.txt），里面记录上次空提交的时间戳。
- 每天运行workflow时，读取这个文件中的时间戳，计算当前时间与上次空提交的时间差，如果超过50天，则进行空提交并更新文件。
但是，这样需要每次workflow都去检查，而且还要处理文件读写。
另一种更简单的方法：利用GitHub Actions的缓存（cache）来存储上次触发的时间，但缓存可能被清除，不够可靠。
或者，我们可以利用Git的tag来标记上次空提交的时间？但tag太多也不太好。
这里我建议使用一个文件来记录时间戳，因为文件会随着提交而保存，可靠。
步骤：
1. 在workflow中，首先检查是否存在记录时间的文件（比如last_active_trigger.txt）。
2. 如果不存在，则创建并记录当前时间，然后提交（这将是第一次空提交）。
3. 如果存在，读取文件中的时间戳，计算当前时间与时间戳的天数差。
4. 如果天数差>=50，则执行空提交：更新这个文件的时间戳为当前时间，然后提交文件。
5. 如果不足50天，则跳过。
注意：这个步骤应该在同一个workflow中，但为了避免每次签到都提交，我们只更新这个触发文件。
但是，这样会导致每次运行workflow都要检查，但大部分时间不会触发提交，所以开销很小。
具体实现：
在workflow中增加一个步骤，放在签到步骤之前或之后，比如：
```yaml
jobs:
  # 原来的签到任务
  sign-in:
    runs-on: ubuntu-latest
    steps:
      - ... # 原来的签到步骤
  # 新增一个保持活跃的任务
  keep-active:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PERSONAL_TOKEN }} # 需要创建一个有写权限的token，并设置为仓库的secret（命名为PERSONAL_TOKEN）
      - name: Get current date
        id: date
        run: echo "current_date=$(date -u +'%Y-%m-%d')" >> $GITHUB_OUTPUT
      - name: Check last trigger time
        id: check_last_trigger
        run: |
          if [ -f "last_active_trigger.txt" ]; then
            last_trigger=$(cat last_active_trigger.txt)
            echo "last_trigger=$last_trigger" >> $GITHUB_OUTPUT
            # 计算天数差（需要跨平台支持，这里使用简单的日期计算，在ubuntu中可以使用date命令）
            current_seconds=$(date -d "${{ steps.date.outputs.current_date }}" +%s)
            last_seconds=$(date -d "$last_trigger" +%s)
            diff_days=$(( (current_seconds - last_seconds) / 86400 ))
            echo "diff_days=$diff_days" >> $GITHUB_OUTPUT
            if [ $diff_days -ge 50 ]; then
              echo "should_trigger=true" >> $GITHUB_OUTPUT
            else
              echo "should_trigger=false" >> $GITHUB_OUTPUT
            fi
          else
            # 文件不存在，需要触发
            echo "should_trigger=true" >> $GITHUB_OUTPUT
          fi
      - name: Update trigger file and commit if necessary
        if: steps.check_last_trigger.outputs.should_trigger == 'true'
        run: |
          echo "${{ steps.date.outputs.current_date }}" > last_active_trigger.txt
          git config user.name "github-actions"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add last_active_trigger.txt
          git commit -m "chore: update last active trigger"
          git push
```
注意：上述步骤中，我们使用了一个名为`PERSONAL_TOKEN`的secret，这是因为默认的`GITHUB_TOKEN`在push时可能没有足够的权限（尤其是在默认分支上），或者使用`GITHUB_TOKEN`也可以，但需要设置仓库的workflow权限为允许写入。
另外，日期计算部分，在Ubuntu的runner中，`date -d`可以解析日期，然后转换为秒数。
但是，这个方案有一个问题：如果workflow每天运行，那么在第50天的时候会触发一次提交，然后重置时间。这样就能保持仓库活动。
但是，我们需要注意，如果某次workflow运行失败了，那么可能错过触发时间。不过50天是一个比较长的时间，即使错过一次，下一次运行（第二天）也会触发，因为此时距离上次已经51天了（如果上次触发是50天前，那么现在就是51天前），所以还是会触发。这样最多会延迟1天，但不会超过60天，所以是安全的。
另外，为了避免在仓库没有其他提交的情况下，这个空提交成为唯一的提交，我们可以考虑将触发条件设置为50天，这样在60天期限之前我们会有活动。
但是，我们还需要考虑GitHub的60天不活动是从最后一次活动事件开始算的，所以只要我们在50天左右有一次提交，那么就能重置计时。
因此，这个方案是可行的。
最后，我们需要将这个job加入到workflow中，并确保它和原来的签到任务可以同时运行（或者顺序运行）。注意，如果原来的签到任务已经有一个checkout步骤，那么在这个keep-active任务中也需要checkout，因为它们是两个独立的job。
另外，为了避免两个job同时操作同一个工作目录，我们可以将它们分开，或者使用不同的步骤。但是，由于我们是两个独立的job，所以它们会在不同的runner上运行，不会相互干扰。
因此，完整的workflow文件可能如下：
```yaml
name: Daily Auto Sign-in
on:
  schedule:
    - cron: '0 0 * * *'   # 每天UTC时间0点运行
  workflow_dispatch:       # 允许手动触发
jobs:
  sign-in:
    runs-on: ubuntu-latest
    steps:
      # 原来的签到步骤
      - name: Checkout
        uses: actions/checkout@v4
      # ... 其他签到步骤
  keep-active:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }} # 优先使用PERSONAL_TOKEN，如果没有则使用GITHUB_TOKEN
          fetch-depth: 0
      - name: Get current date
        id: date
        run: echo "current_date=$(date -u +'%Y-%m-%d')" >> $GITHUB_OUTPUT
      - name: Check last trigger time
        id: check_last_trigger
        run: |
          if [ -f "last_active_trigger.txt" ]; then
            last_trigger=$(cat last_active_trigger.txt)
            echo "last_trigger=$last_trigger" >> $GITHUB_OUTPUT
            current_seconds=$(date -d "${{ steps.date.outputs.current_date }}" +%s)
            last_seconds=$(date -d "$last_trigger" +%s)
            diff_days=$(( (current_seconds - last_seconds) / 86400 ))
            echo "diff_days=$diff_days" >> $GITHUB_OUTPUT
            if [ $diff_days -ge 50 ]; then
              echo "should_trigger=true" >> $GITHUB_OUTPUT
            else
              echo "should_trigger=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_trigger=true" >> $GITHUB_OUTPUT
            echo "last_trigger=none" >> $GITHUB_OUTPUT
          fi
      - name: Update trigger file and commit if necessary
        if: steps.check_last_trigger.outputs.should_trigger == 'true'
        run: |
          echo "${{ steps.date.outputs.current_date }}" > last_active_trigger.txt
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add last_active_trigger.txt
          git commit -m "chore: update last active trigger [skip ci]"
          git push
```
注意：
- 我们使用了`[skip ci]`来避免这个提交再次触发workflow（如果workflow是由push触发的话）。但是我们的workflow是由schedule触发的，所以即使push也不会触发新的workflow（除非你设置了push事件触发）。所以这里可以不加，但加上也无妨。
- 关于token：如果使用`GITHUB_TOKEN`，需要确保它有写入权限。在仓库的Settings > Actions > General > Workflow permissions中，勾选“Read and write permissions”。然后就可以用`secrets.GITHUB_TOKEN`了。这样就不需要额外创建PERSONAL_TOKEN。
- 但是，注意：使用`GITHUB_TOKEN`推送的提交不会触发workflow（这是GitHub的默认行为），所以这样不会导致递归触发。因此，这里使用`GITHUB_TOKEN`是安全的。
因此，我们可以去掉`PERSONAL_TOKEN`，直接使用`GITHUB_TOKEN`：
```yaml
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
```
这样更简单。
最后，将修改后的workflow文件提交到仓库，然后观察运行情况。
注意：第一次运行时，因为还没有last_active_trigger.txt文件，所以会创建并提交。之后每50天会提交一次。
这样，我们就保证了仓库每50天有一次提交活动，从而不会被GitHub禁用workflow。

---

要解决 GitHub 仓库因 60 天无活动导致 Workflow 被禁用的问题，以下是几种自动化解决方案，无需手动干预：

### 方案一：添加定期空提交（推荐）
在现有 Workflow 中添加一个定期提交任务，每 50 天自动创建一次空提交来激活仓库。

```yaml
jobs:
  keep-alive:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate days
        id: date
        run: |
          LAST_COMMIT=$(git log -1 --format=%ct)
          CURRENT=$(date +%s)
          DAYS_DIFF=$(( ($CURRENT - $LAST_COMMIT) / 86400 ))
          echo "days_diff=$DAYS_DIFF" >> $GITHUB_OUTPUT

      - name: Create empty commit
        if: steps.date.outputs.days_diff > 50
        run: |
          git config user.name "github-actions"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git commit --allow-empty -m "Keep-alive commit"
          git push
```

### 方案二：使用外部监控服务
通过免费服务定期访问仓库 API 触发活动：

1. **使用 UptimeRobot + GitHub API**：
   - 在 UptimeRobot 创建 HTTP 监控
   - 监控 URL：`https://api.github.com/repos/你的用户名/你的仓库名`
   - 设置每 30 天访问一次
   - 添加 Basic Auth 头（使用你的 GitHub 用户名和 Personal Token）

2. **使用 cron-job.org**：
   ```bash
   curl -H "Authorization: token YOUR_GITHUB_TOKEN" \
   -X PATCH https://api.github.com/repos/USER/REPO \
   -d '{"name":"REPO"}'
   ```
   设置每月执行一次此请求

### 方案三：创建定期 Issues（无代码变更）
```yaml
on:
  schedule:
    - cron: '0 0 1 */2 *'  # 每两个月运行一次

jobs:
  create-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create Issue
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'Keep-alive issue',
              body: 'Automatic repository activity trigger'
            })
```

### 方案四：使用 Repository Dispatch
1. 创建触发端点：
   ```yaml
   on:
     repository_dispatch:
       types: [keep-alive]
   ```
2. 通过外部服务定期调用：
   ```bash
   curl -X POST \
   -H "Authorization: token YOUR_TOKEN" \
   -H "Accept: application/vnd.github.v3+json" \
   https://api.github.com/repos/USER/REPO/dispatches \
   -d '{"event_type":"keep-alive"}'
   ```

### 最佳实践建议
1. **组合使用**：方案一（空提交）+ 方案二（外部监控）双重保险
2. **安全设置**：
   - 使用 `secrets.GITHUB_TOKEN` 无需额外配置
   - 如需 Personal Token，需赋予 `repo` 权限
3. **优化频率**：建议每 30-50 天触发一次
4. **添加跳过标签**：在空提交消息中添加 `[skip ci]` 避免额外触发

这些方案都能确保仓库保持活动状态，其中方案一实现最简单且完全免费，推荐优先采用。所有方法都无需手动操作，可永久解决 60 天失效问题。
